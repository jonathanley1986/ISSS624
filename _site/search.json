[
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html",
    "href": "Hands-on_Ex/Hands-on_Ex2.html",
    "title": "Hands-on_Ex2",
    "section": "",
    "text": "We will learn how to compute Global and Local Measure of Spatial Autocorrelation (GLSA) by using spdep package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#getting-started",
    "title": "Hands-on_Ex2",
    "section": "Getting Started",
    "text": "Getting Started\n\nThe Analytical Question\nOur task in this study, hence, is to apply appropriate spatial statistical methods to discover if development are even distributed geographically.\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China.\n\n\nThe Study Area and Data\n2 datasets will be used in this hands-on exercise:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan's local development indicators in 2012.\n\n\n\nSetting the Analytical Tools\nThe code chunk below is used to perform the following tasks:\n\nCreating a package list containing the necessary R packages,\nChecking if the R packages in the package list have been installed in R,\n\nIf they have yet to be installed, RStudio will installed the missing packages,\n\nLaunching the packages into R environment.\n\n\npacman::p_load(sf, spdep, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#getting-the-data-into-r-environment",
    "title": "Hands-on_Ex2",
    "section": "Getting the Data Into R Environment",
    "text": "Getting the Data Into R Environment\nWe will learn how to bring a geospatial data and its associated attribute table into R environment.\n\nImport shapefile into r environment\nThe code chunk below uses st_read() of sf package to import Hunan shapefile into R. The imported shapefile will be simple features Object of sf.\n\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/jonathanley/Dropbox/SMU Modules/ISSS624 - Applied Geospatial Analytics/Quarto/jonathanley1986/ISSS624/Hands-on_Ex/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\nImport csv file into r environment\nNext, we will import Hunan_2012.csv into R by using read_csv() of readr package.\n\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\",show_col_types = FALSE)\n\n\n\nPerforming relational join\nThe code chunk below will be used to update the attribute table of hunan's SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe.\n\nhunan <- left_join(hunan,hunan2012)\n\nJoining, by = \"County\"\n\n\n\n\nVisualising Regional Development Indicator\nWe are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#global-spatial-autocorrelation",
    "title": "Hands-on_Ex2",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\nWe will learn how to compute global spatial autocorrelation statistics and to perform spatial complete randomness test for global spatial autocorrelation.\n\nComputing Contiguity Spatial Weights\nThe spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\nIn the code chunk below, poly2nb() of spdep package is used to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries.\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n\nRow-standardised weights matrix\nWe need to assign weights to each neighboring polygon. In our case, each neighboring polygon will be assigned equal weight (style=\"W\").\n\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\n\nGlobal Spatial Autocorrelation: Moran's I\nWe will learn how to perform Moran's I statistics testing by using moran.test() of spdep.\n\n\nMaron's I test\nThe code chunk below performs Moran's I statistical testing using moran.test() of spdep.\n\nmoran.test(hunan2012$GDPPC, \n           listw = rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan2012$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = -0.55119, p-value = 0.7092\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     -0.047840901      -0.011494253       0.004348351 \n\n\n\nComputing Monte Carlo Moran's I\nThe code chunk below performs permutation test for Moran's I statistic by using moran.mc() of spdep. A total of 1000 simulation will be performed.\n\nset.seed(1234)\nbperm= moran.mc(hunan2012$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan2012$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = -0.047841, observed rank = 321, p-value = 0.679\nalternative hypothesis: greater\n\n\n\n\nVisualising Monte Carlo Moran's I\nWe will plot the distribution of the statistical values as a histogram by using the code chunk below.\nIn the code chunk below hist() and abline() of R Graphics are used.\n\nmean(bperm$res[1:999])\n\n[1] -0.01305777\n\n\n\nvar(bperm$res[1:999]) \n\n[1] 0.004542948\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.17956 -0.06141 -0.01743 -0.01306  0.02887  0.23587 \n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n\nGlobal Spatial Autocorrelation: Geary's\nWe will learn how to perform Geary's c statistics testing by using appropriate functions of spdep package.\nThe code chunk below performs Geary's C test for spatial autocorrelation by using geary.test() of spdep.\n\ngeary.test(hunan2012$GDPPC, listw=rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan2012$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = -0.36832, p-value = 0.6437\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        1.0315475         1.0000000         0.0073364 \n\n\n\nComputing Monte Carlo Geary's C\nThe code chunk below performs permutation test for Geary's C statistic by using geary.mc() of spdep.\n\nset.seed(1234)\nbperm=geary.mc(hunan2012$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan2012$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 1.0315, observed rank = 638, p-value = 0.638\nalternative hypothesis: greater\n\n\n\n\nVisualising the Monte Carlo Geary's C\nWe will plot a histogram to reveal the distribution of the simulated values by using the code chunk below.\n\nmean(bperm$res[1:999])\n\n[1] 1.000736\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.007486288\n\n\n\nsummary(bperm$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7091  0.9416  1.0034  1.0007  1.0560  1.3396 \n\n\n\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#spatial-correlogram",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#spatial-correlogram",
    "title": "Hands-on_Ex2",
    "section": "Spatial Correlogram",
    "text": "Spatial Correlogram\nThey show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran's I or Geary's c) against distance.\nThey are very useful as an exploratory and descriptive tool. For this purpose they actually provide richer information than variograms.\n\nCompute Moran's I correlogram\nIn the code chunk below, sp.correlogram() of spdep package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Moran's I. The plot() of base Graph is then used to plot the output.\n\nMI_corr <- sp.correlogram(wm_q, \n                          hunan2012$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n\n\n\nprint(MI_corr)\n\nSpatial correlogram for hunan2012$GDPPC \nmethod: Moran's I\n          estimate expectation    variance standard deviate Pr(I) two sided\n1 (88) -0.04784090 -0.01149425  0.00434835          -0.5512          0.5815\n2 (88) -0.03164659 -0.01149425  0.00209624          -0.4402          0.6598\n3 (88) -0.00013462 -0.01149425  0.00146019           0.2973          0.7663\n4 (88)  0.00398743 -0.01149425  0.00117166           0.4523          0.6511\n5 (88) -0.06581650 -0.01149425  0.00124395          -1.5402          0.1235\n6 (88) -0.00729186 -0.01149425  0.00167910           0.1026          0.9183\n\n\n\n\nCompute Geary's C correlogram and plot\nIn the code chunk below, sp.correlogram() of spdep package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary's C. The plot() of base Graph is then used to plot the output.\n\nGC_corr <- sp.correlogram(wm_q, \n                          hunan2012$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n\n\n\nprint(GC_corr)\n\nSpatial correlogram for hunan2012$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided  \n1 (88) 1.0315475   1.0000000 0.0073364           0.3683         0.71264  \n2 (88) 0.9329020   1.0000000 0.0049126          -0.9573         0.33841  \n3 (88) 0.9299705   1.0000000 0.0049005          -1.0004         0.31713  \n4 (88) 0.9659343   1.0000000 0.0039631          -0.5411         0.58842  \n5 (88) 1.1380900   1.0000000 0.0035568           2.3154         0.02059 *\n6 (88) 1.0477936   1.0000000 0.0058042           0.6273         0.53044  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#cluster-and-outlier-analysis",
    "title": "Hands-on_Ex2",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\nWe will learn how to apply appropriate Local Indicators for Spatial Association (LISA), especially local Moran'I to detect cluster and/or outlier from GDP per capita 2012 of Hunan Province, PRC.\n\nComputing local Moran's I\nTo compute local Moran's I, the localmoran() function of spdep will be used. It computes Ii values, given a set of zi values and a listw object providing neighbour weighting information for the polygon associated with the zi values.\nThe code chunks below are used to compute local Moran's I of GDPPC2012 at the county level.\n\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan2012$GDPPC, rswm_q)\nhead(localMI)\n\n             Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.0447465780 -5.004845e-03 8.356794e-02 -0.1374760      0.8906545\n2  0.0408817387 -7.011066e-03 1.168306e-01  0.1401174      0.8885672\n3  0.0231470020 -2.815006e-05 5.976810e-04  0.9479553      0.3431522\n4  0.1648163587 -5.008916e-03 1.058194e-01  0.5220591      0.6016292\n5  0.0703372941 -9.681197e-04 2.053576e-02  0.4975848      0.6187767\n6 -0.0002739628 -9.001050e-09 1.510502e-07 -0.7048826      0.4808833\n\n\nThe code chunk below list the content of the local Moran matrix derived by using printCoefmat().\n\nprintCoefmat(data.frame(localMI[fips,], row.names=hunan2012$County[fips]), check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nShaodong       3.1808e-03 -3.6592e-05  4.2790e-04  1.5554e-01         0.8764\nCili           7.0089e-02 -1.6747e-03  1.6894e-02  5.5213e-01         0.5809\nAnhua         -4.4747e-02 -5.0048e-03  8.3568e-02 -1.3748e-01         0.8907\nNan            1.0804e-01 -4.9497e-04  8.3022e-03  1.1912e+00         0.2336\nXiangyin      -4.0731e-01 -4.7442e-03  1.3528e-01 -1.0945e+00         0.2737\nHanshou        5.4785e-02 -6.0620e-04  1.0167e-02  5.4935e-01         0.5828\nYueyang        1.2372e-01 -1.9768e-04  2.7303e-03  2.3716e+00         0.0177\nLianyuan      -1.3580e-02 -1.8983e-03  4.0230e-02 -5.8241e-02         0.9536\nHuarong       -4.5796e-02 -1.8667e-03  3.1268e-02 -2.4843e-01         0.8038\nXiangxiang    -1.0296e-01 -1.2703e-03  3.6348e-02 -5.3338e-01         0.5938\nZhuzhou        1.1903e-01 -5.2432e-04  1.1127e-02  1.1334e+00         0.2571\nLiling        -7.5950e-01 -1.5097e-02  3.1570e-01 -1.3249e+00         0.1852\nLinli          4.7057e-02 -6.8294e-05  1.1460e-03  1.3921e+00         0.1639\nNingxiang     -1.4998e+00 -7.3878e-02  1.4527e+00 -1.1830e+00         0.2368\nDao            3.1253e-01 -2.0824e-03  5.9539e-02  1.2893e+00         0.1973\nYuanling       5.4459e-03 -2.2981e-06  2.0380e-05  1.2069e+00         0.2275\nNingyuan       2.6616e-01 -7.0884e-03  1.1811e-01  7.9508e-01         0.4266\nAnren          4.0882e-02 -7.0111e-03  1.1683e-01  1.4012e-01         0.8886\nHengdong      -6.3606e-02 -4.9063e-04  6.7742e-03 -7.6685e-01         0.4432\nHengnan        2.4216e-02 -3.2160e-04  3.7597e-03  4.0018e-01         0.6890\nHengshan       3.3641e-02 -3.0437e-05  5.1076e-04  1.4899e+00         0.1363\nYuanjiang      6.4942e-02 -1.7760e-04  2.9798e-03  1.1929e+00         0.2329\nYou            2.8095e-01 -7.2728e-03  9.9736e-02  9.1264e-01         0.3614\nTaoyuan       -7.0785e-02 -1.2039e-04  5.2350e-03 -9.7667e-01         0.3287\nPingjiang     -3.0356e-01 -2.6457e-03  7.5603e-02 -1.0944e+00         0.2738\nHuitong       -6.1100e-01 -5.2447e-03  1.1077e-01 -1.8200e+00         0.0688\nDongan         8.0028e-02 -6.3485e-04  1.0647e-02  7.8174e-01         0.4344\nShimen         1.0870e-01 -3.8603e-04  8.1932e-03  1.2052e+00         0.2281\nZixing         5.4967e-01 -8.8210e-02  3.4977e+00  3.4107e-01         0.7330\nJiahe          2.4673e-01 -3.0550e-03  8.7263e-02  8.4559e-01         0.3978\nAnxiang        2.3147e-02 -2.8150e-05  5.9768e-04  9.4796e-01         0.3432\nQidong        -1.5696e-02 -2.1207e-03  3.5512e-02 -7.2037e-02         0.9426\nShuangfeng     1.0770e-01 -2.2867e-03  4.8442e-02  4.9971e-01         0.6173\nHengyang       1.5235e-02 -1.3046e-03  2.1865e-02  1.1186e-01         0.9109\nLeiyang        1.6271e-02 -1.4948e-04  4.2822e-03  2.5093e-01         0.8019\nBaojing        1.6482e-01 -5.0089e-03  1.0582e-01  5.2206e-01         0.6016\nYongxing       3.4893e-01 -9.0735e-03  9.0853e-02  1.1877e+00         0.2349\nXinhua        -6.2209e-01 -6.2649e-03  1.7837e-01 -1.4581e+00         0.1448\nChaling        7.0337e-02 -9.6812e-04  2.0536e-02  4.9758e-01         0.6188\nDongkou        3.2991e-01 -6.4461e-03  1.3598e-01  9.1214e-01         0.3617\nTongdao        5.5129e-01 -6.9870e-03  6.1056e-01  7.1447e-01         0.4749\nChangsha      -2.4740e+00 -2.1348e-01  3.5651e+00 -1.1972e+00         0.2312\nLinwu          7.9061e-03 -9.0703e-06  1.2530e-04  7.0711e-01         0.4795\nQiyang         1.2910e-01 -7.3374e-04  2.1007e-02  8.9577e-01         0.3704\nRucheng       -2.3827e-01 -8.8999e-03  1.2185e-01 -6.5709e-01         0.5111\nJianghua      -1.7265e-01 -3.8280e-03  6.3994e-02 -6.6738e-01         0.5045\nWangcheng     -1.0657e+00 -1.1067e-01  1.6517e+00 -7.4315e-01         0.4574\nShaoshan      -1.2196e+00 -5.0227e-02  6.5898e-01 -1.4405e+00         0.1497\nChengbu       -1.2834e-01 -1.0534e-02  1.2190e-01 -3.3741e-01         0.7358\nShuangpai      3.3007e-02 -3.1366e-04  3.6669e-03  5.5026e-01         0.5821\nWugang        -1.4093e+00 -7.8144e-03  1.6462e-01 -3.4540e+00         0.0006\nHongjiang     -9.9283e-03 -2.3019e-03  2.6857e-02 -4.6537e-02         0.9629\nYanling        1.9388e-02 -5.9211e-04  6.9203e-03  2.4018e-01         0.8102\nFenghuang      5.7986e-01 -6.2832e-03  1.7889e-01  1.3858e+00         0.1658\nXintian        3.9902e-02 -5.1493e-03  7.0766e-02  1.6936e-01         0.8655\nLinxiang       1.4905e-01 -2.9028e-03  3.9982e-02  7.5995e-01         0.4473\nMayang        -1.6404e-01 -5.8773e-03  1.6740e-01 -3.8657e-01         0.6991\nYongshun       1.8023e-01 -1.1350e-02  1.3122e-01  5.2887e-01         0.5969\nChangning     -2.7396e-04 -9.0010e-09  1.5105e-07 -7.0488e-01         0.4809\nLengshuijiang  1.4311e+00 -8.2129e-02  1.0414e+00  1.4829e+00         0.1381\nSuining        3.3283e-02 -3.5933e-03  1.0258e-01  1.1513e-01         0.9083\nLiuyang       -4.3554e-01 -7.7502e-02  8.3609e-01 -3.9156e-01         0.6954\nYizhang        2.0518e-01 -2.2463e-03  2.6210e-02  1.2812e+00         0.2001\nZhijiang      -1.5772e-03 -7.8123e-04  5.5188e-03 -1.0714e-02         0.9915\nJiangyong     -4.3781e-01 -2.7082e-03  7.7384e-02 -1.5641e+00         0.1178\nChenxi        -2.0167e-01 -2.8156e-03  3.8785e-02 -1.0097e+00         0.3126\nLonghui       -4.3589e-02 -1.1377e-02  1.5538e-01 -8.1718e-02         0.9349\nZhongfang      5.9708e-02 -2.1455e-03  1.8986e-02  4.4890e-01         0.6535\nMiluo          5.6336e-01 -1.6927e-02  2.7925e-01  1.0981e+00         0.2722\nXiangtan       1.6719e-02 -3.6457e-04  6.1158e-03  2.1845e-01         0.8271\nLi             9.5226e-04 -2.4048e-07  3.3220e-06  5.2260e-01         0.6013\nJingzhou       7.8788e-02 -8.5106e-04  7.4830e-02  2.9113e-01         0.7710\nLongshan       3.0683e-01 -1.1100e-02  2.3306e-01  6.5856e-01         0.5102\nLuxi          -3.7809e-02 -2.4855e-03  3.4249e-02 -1.9087e-01         0.8486\nTaojiang       5.2649e-02 -1.2395e-03  2.6285e-02  3.3239e-01         0.7396\nJinshi         1.2931e-01 -5.3666e-03  5.3937e-02  5.7990e-01         0.5620\nXinhuang       5.5307e-02 -4.1820e-03  6.9886e-02  2.2503e-01         0.8220\nGuidong        6.3022e-01 -1.3086e-02  2.7422e-01  1.2285e+00         0.2193\nSangzhi        1.8847e-01 -4.9470e-03  8.2607e-02  6.7295e-01         0.5010\nGuiyang       -2.4889e-01 -3.6908e-03  6.1708e-02 -9.8708e-01         0.3236\nXinning        2.0829e-01 -9.6674e-03  1.6066e-01  5.4375e-01         0.5866\nShaoyang      -6.6952e-02 -1.1253e-02  1.8672e-01 -1.2890e-01         0.8974\nJishou        -1.2609e-01 -2.6305e-03  2.6510e-02 -7.5825e-01         0.4483\nXupu          -2.7025e-01 -5.7468e-03  6.6819e-02 -1.0233e+00         0.3062\nLanshan        5.8031e-02 -9.6365e-04  1.6156e-02  4.6414e-01         0.6425\nHuayuan       -5.5393e-02 -8.5569e-04  1.4347e-02 -4.5531e-01         0.6489\nXinshao       -4.9343e-01 -8.5932e-03  1.1769e-01 -1.4133e+00         0.1576\nGuzhang        3.2742e-01 -8.5054e-03  9.8619e-02  1.0697e+00         0.2848\n\n\n\nMapping the local Moran's I\nThe code chunks below can be used to perform the task. The out SpatialPolygonDataFrame is called hunan.localMI.\n\nhunan.localMI <- cbind(hunan,localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\nMapping local Moran's I values\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\nMapping local Moran's I p-values\nThe code chunks below produce a choropleth map of Moran's I p-values by using functions of tmap package.\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMapping both local Moran's I values and p-values\nThe code chunk below will be used to create such visualisation.\n\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#creating-a-lisa-cluster-map",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#creating-a-lisa-cluster-map",
    "title": "Hands-on_Ex2",
    "section": "Creating a LISA Cluster Map",
    "text": "Creating a LISA Cluster Map\nThe first step before we can generate the LISA cluster map is to plot the Moran scatterplot.\n\nPlotting Moran scatterplot\nThe code chunk below plots the Moran scatterplot of GDPPC 2012 by using moran.plot() of spdep.\n\nnci <- moran.plot(hunan2012$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\n\n\nPlotting Moran scatterplot with standardised variable\nWe will use scale() to centers and scales the variable. Here centering is done by subtracting the mean (omitting NAs) the corresponding columns, and scaling is done by dividing the (centered) variable by their standard deviations.\n\nhunan$Z.GDPPC <- scale(hunan2012$GDPPC) %>% as.vector \n\nThe as.vector() added to the end is to make sure that the data type we get out of this is a vector, that map neatly into out dataframe.\nNow, we are ready to plot the Moran scatterplot again by using the code chunk below.\n\nnci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\n\n\nPreparing LISA map classes\nThe code chunks below show the steps to prepare a LISA cluster map.\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\nWe centers the variable of interest around its mean.\n\nDV <- hunan2012$GDPPC - mean(hunan2012$GDPPC)     \n\nNext, we center the local Moran's around the mean.\n\nC_mI <- localMI[,1] - mean(localMI[,1])    \n\nWe will set a statistical significance level for the local Moran.\n\nsignif <- 0.05       \n\nThese four command lines define the high-high, low-low, low-high and high-low categories.\n\nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\n\nLastly, we place non-significant Moran in the category 0.\n\nquadrant[localMI[,5]>signif] <- 0\n\nWe can combined all the steps into one single code chunk as shown below:\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\nDV <- hunan2012$GDPPC - mean(hunan2012$GDPPC)     \nC_mI <- localMI[,1] - mean(localMI[,1])    \nsignif <- 0.05       \nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\nquadrant[localMI[,5]>signif] <- 0\n\n\n\nPlotting LISA map\nWe can build the LISA map by using the code chunks below.\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\n\n\n\nFor effective interpretation, it is better to plot both the local Moran's I values map and its corresponding p-values map next to each other.\nThe code chunk below will be used to create such visualisation.\n\ngdppc <- qtm(hunan, \"GDPPC\")\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\ntmap_arrange(gdppc, LISAmap, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Hands-on_Ex2",
    "section": "Hot Spot and Cold Spot Area Analysis",
    "text": "Hot Spot and Cold Spot Area Analysis\n\nGetis and Ord's G-Statistics\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\nDeriving distance-based weight matrix\nWe need to define a new set of neighbours. Whist the spatial autocorrelation considered units which shared borders, for Getis-Ord we are defining neighbours based on distance.\nThere are two type of distance-based proximity matrix, they are:\n\nfixed distance weight matrix; and\nadaptive distance weight matrix.\n\n\nDeriving the centroid\nTo get our longitude values we map the st_centroid() function over the geometry column of us.bound and access the longitude value through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with [[2]].\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nWe use cbind to put longitude and latitude into the same object.\n\ncoords <- cbind(longitude, latitude)\n\n\n\nDetermine the cut-off distance\nWe need to determine the upper limit for distance band by using the steps below:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep.\nConvert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().\nReturn the length of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.\nRemove the list structure of the returned object by using unlist().\n\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\n\n\nComputing fixed distance weight matrix\nWe will compute the distance weight matrix by using dnearneigh() as shown in the code chunk below.\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nnb2listw() is used to convert the nb object into spatial weights object.\n\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\n\n\n\nComputing adaptive distance weight matrix\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\nnb2listw() is used to convert the nb object into spatial weights object.\n\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex2.html#computing-gi-statistics",
    "href": "Hands-on_Ex/Hands-on_Ex2.html#computing-gi-statistics",
    "title": "Hands-on_Ex2",
    "section": "Computing Gi statistics",
    "text": "Computing Gi statistics\n\nGi statistics using fixed distance\n\nfips <- order(hunan2012$County)\ngi.fixed <- localG(hunan2012$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.433827693  0.183954700  0.241844939 -0.595319857 -0.832123080\n [6]  0.330549467 -0.473921724 -0.245500449 -0.702344021  0.127364731\n[11] -1.289345911 -0.781740107 -0.912136864 -0.924287997 -0.761800884\n[16] -0.794412114 -0.366334446 -0.488341213 -0.802294323 -0.088267981\n[21]  1.007041663 -0.115182635  0.223559910 -0.520736111  0.161631089\n[26]  1.820028665 -0.813850800  0.430195973  0.069397791 -0.291131045\n[31]  0.300149148 -0.776373646 -0.464136584  0.250932078  0.982109817\n[36]  0.581746065  1.487891174 -1.266469507  1.200740981 -0.803089907\n[41]  0.419573869 -0.500212351  0.967848526  0.091422238  0.190870184\n[46]  1.290368505  1.098113045 -1.191217855 -1.183048267 -0.935447307\n[51]  0.552749823 -0.177535815 -0.615041671  0.501209741 -0.986697187\n[56]  0.005192887 -1.150425459  2.029343987  1.478046902 -0.499707954\n[61] -0.621450130 -0.270046405 -0.556816184 -0.137016618 -0.714467037\n[66] -0.981955481  5.249310294  0.889745324 -0.467612308 -1.094510150\n[71] -1.276053331 -0.108088913 -0.404796809 -0.464193791 -0.240357119\n[76]  1.279561290  0.076459001 -1.237935051  0.564829217  1.642857763\n[81]  0.677148751  1.182722996 -0.377651787  3.594235457 -0.762103626\n[86] -0.149378175  1.133367094  0.341071937\nattr(,\"cluster\")\n [1] Low  Low  Low  Low  Low  High High Low  Low  Low  Low  Low  Low  Low  Low \n[16] High Low  Low  High Low  High Low  Low  High Low  Low  High Low  Low  Low \n[31] High High Low  High High High Low  High High Low  High High Low  Low  Low \n[46] Low  High Low  High Low  Low  Low  Low  Low  Low  High High Low  High Low \n[61] Low  Low  Low  Low  Low  High Low  High High High Low  Low  Low  Low  Low \n[76] Low  Low  Low  Low  High High High Low  High Low  High High High\nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan2012$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nWe will join the Gi values to their corresponding hunan sf data frame by using the code chunk below.\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\nThe code chunk above performs three tasks. First, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix(). Next, cbind() is used to join hunan@data and gi.fixed matrix to produce a new SpatialPolygonDataFrame called hunan.gi. Lastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\n\nMapping Gi values with fixed distance weights\nThe code chunk below shows the functions used to map the Gi values derived using fixed distance weight matrix.\n\ngdppc <- qtm(hunan, \"GDPPC\")\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\nGi statistics using adaptive distance\nThe code chunk below are used to compute the Gi values for GDPPC2012 by using an adaptive distance weight matrix (i.e knb_lw).\n\nfips <- order(hunan2012$County)\ngi.adaptive <- localG(hunan2012$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\nMapping Gi values with adaptive distance weights\nThe code chunk below shows the functions used to map the Gi values derived using fixed distance weight matrix.\n\ngdppc<- qtm(hunan, \"GDPPC\")\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  }
]