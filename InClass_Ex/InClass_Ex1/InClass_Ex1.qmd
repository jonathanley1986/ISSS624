---
title: "In-class Exercise 1"
editor: visual
---

## Overview

This is an exercise that will compute spatial weights using R.

### Getting Started (Load Code)

The code chunk below will install and load tidyverse and sf packages.

Note: Specify package name in the code chunk if it is not loaded in the library.

```{r}
pacman::p_load(sf, tidyverse, spdep, tmap)
```

### Importing Geospatial Data

#### Importing polygon features

This code chunk below will import ESRI stepfile into R.

```{r}
mpsz <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
```

Importing and transforming projected coordinates system

Note: For SG coordinates, you need to transform to CRS = 3414

```{r}
preschool = st_read("data/geospatial/pre-schools-location-kml.kml") %>%
  st_transform(crs = 3414)
```

```{r}
hunan <- st_read(dsn = "data/geospatial", layer = "Hunan")
```

#### Importing shapefile into R environment

The code chunk below uses st_read() of sf package to import Hunan shapefile into R.

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

#### Importing csv file into R environment

We will use read_csv() of readr package to import Hunan_2012.csv into R environment.

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv", show_col_types = FALSE)

```

#### Perform relational join

```{r}
hunan1 <- left_join(hunan, hunan2012) 
```

## Visualizing Regional Development Indicator

```{r}
basemap <- tm_shape(hunan1) +
  tm_polygons() +
  tm_text("NAME_3", size=0.3) +
  tm_layout(legend.width = 0.01)

gdppc <- qtm(hunan1, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)

```

## Computing Contiguity Spatial Weights

### Computing (Queen) Contiguity based Neighbours

The code chunk below is used to compute Queen contiguity weight matrix.

```{r}
wm_q <- poly2nb(hunan1, queen=TRUE)
summary(wm_q)

```

#### Retrieval of information

```{r}
wm_q[[1]] 

hunan1$County[1]

hunan1$NAME_3[c(2,3,4,57,85)]

nb1 <- wm_q[[1]]
nb1 <- hunan1$GDPPC[nb1]
nb1

str(wm_q)
```

### Computing (ROOK) Contiguity based Neighbours

The code chunk below is used to compute Rook contiguity weight matrix.

```{r}
wm_r <- poly2nb(hunan1, queen=FALSE)
summary(wm_r)
```

## Visualizing Contiguity Weights

```{r}
longitude <- map_dbl(hunan1$geometry, ~st_centroid(.x)[[1]])

latitude <- map_dbl(hunan1$geometry, ~st_centroid(.x)[[2]])

coords <- cbind(longitude, latitude)

head(coords)

```

### Plotting Queen Contiguity Based Neighbours

```{r}
plot(hunan1$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

### Plotting Rook Contiguity Based Neighbours

```{r}
plot(hunan1$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### Plotting Both Queen Rook Contiguity Based Neighbours

```{r}
par(mfrow=c(1,2))
plot(hunan1$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan1$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

## Computing Distance Based Neighbours

We will learn to derive distance-based weight matrices using dnearneigh() of spdep package.

### Determine cut-off distance

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62

str(wm_d62)

table(hunan1$County, card(wm_d62))

n_comp <- n.comp.nb(wm_d62)
n_comp$nc

table(n_comp$comp.id)

```

#### Plotting fixed distance weight matrix

```{r}
plot(hunan1$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

```{r}
par(mfrow=c(1,2))
plot(hunan1$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
plot(hunan1$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
```

### Computing adaptive distance weight matrix

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6

str(knn6)
```

#### Plotting distance based neighbours

```{r}
plot(hunan1$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

```

## Weights based on IDW

We will learn to derive spatial weight matrix based on inversed distance method.

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

### Row standardized weights matrix

Assign weights to each neighbouring polygon.

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

rswm_q$weights[10]

rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids

summary(unlist(rswm_ids$weights))
```

## Application of Spatial Weight Matrix

We will learn to create 4 different spatial lagged variables.

### Spatial Lag with Row-Standardized Weights

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan1$GDPPC)
GDPPC.lag
```

We retrieved GDPPC of these 5 countries by the code chunk below.

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan1$GDPPC[nb1]
nb1
```

We append spatially lag GDPPC values onto hunan1 sf data frame with the code chunk below.

```{r}
lag.list <- list(hunan1$NAME_3, lag.listw(rswm_q, hunan1$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan1 <- left_join(hunan1,lag.res)

head(hunan1)
```

We will plot both GDPPC and spatial lag GDPPC for comparison.

```{r}
gdppc <- qtm(hunan1, "GDPPC")
lag_gdppc <- qtm(hunan1, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

### Spatial Lag as a Sum of Neighbouring Values

We calculate spatial lag as a sum of neighboring values by assigning binary weights.

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

Use lag.listw to compute a lag variable from our weight and GDPPC.

```{r}
lag_sum <- list(hunan1$NAME_3, lag.listw(b_weights2, hunan1$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")

lag_sum

```

We will append the *lag_sum GDPPC* field into hunan1 sf data frame by using the code chunk below.

```{r}
hunan1 <- left_join(hunan1, lag.res)
```

We can plot both the *GDPPC* and *Spatial Lag Sum GDPPC* for comparison using the code chunk below.

```{r}
gdppc <- qtm(hunan1, "GDPPC")
lag_sum_gdppc <- qtm(hunan1, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

### Spatial Window Average

The spatial window average uses row-standardized weights and includes the diagonal element.

```{r}
wm_q1 <- wm_q

include.self(wm_q1)

wm_q1 <- nb2listw(wm_q1)
wm_q1

lag_w_avg_gpdpc <- lag.listw(wm_q1, 
                             hunan1$GDPPC)
lag_w_avg_gpdpc
```

We will convert the lag variable listw object into a data.frame by using *as.data.frame()*.

```{r}
lag.list.wm_q1 <- list(hunan1$NAME_3, lag.listw(wm_q1, hunan1$GDPPC))
lag_wm_q1.res <- as.data.frame(lag.list.wm_q1)
colnames(lag_wm_q1.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

The code chunk below will be used to append *lag_window_avg GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.

```{r}
hunan1 <- left_join(hunan1, lag_wm_q1.res)
```

*Qtm()* of **tmap** package is used to plot the GDPPC and lag_window_avg GDPPC map next to each other for quick comparison.

```{r}
gdppc <- qtm(hunan1, "GDPPC")
w_avg_gdppc <- qtm(hunan1, "lag_window_avg GDPPC")
tmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)
```

### Spatial Window Sum

The spatial window sum is the counter part of the window average, but without using row-standardized weights. To do this we assign binary weights to the neighbor structure that includes the diagonal element.

```{r}
wm_q1 <- wm_q
```

To add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.

```{r}
include.self(wm_q1)

wm_q1
```

We will assign binary weights to the neighbour structure that includes the diagonal element.

```{r}
b_weights <- lapply(wm_q1, function(x) 0*x + 1)
b_weights[1]

```

We use *nb2listw()* and *glist()* to explicitly assign weight values.

```{r}
b_weights2 <- nb2listw(wm_q1, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

With our new weight structure, we can compute the lag variable with *lag.listw()*.

```{r}
w_sum_gdppc <- list(hunan1$NAME_3, lag.listw(b_weights2, hunan1$GDPPC))
w_sum_gdppc
```

We will convert the lag variable listw object into a data.frame by using *as.data.frame()*.

```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

The code chunk below will be used to append *w_sum GDPPC* values onto *hunan1* sf data.frame by using *left_join()* of **dplyr** package.

```{r}
hunan1 <- left_join(hunan1, w_sum_gdppc.res)
```

*Qtm()* of **tmap** package is used to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison.

```{r}
gdppc <- qtm(hunan1, "GDPPC")
w_sum_gdppc <- qtm(hunan1, "w_sum GDPPC")
tmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)
```
